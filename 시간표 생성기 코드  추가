import streamlit as st
import pandas as pd
import numpy as np
import re, random
from sentence_transformers import SentenceTransformer, util
import os

st.set_page_config(page_title="2025 AI 시간표 생성기", layout="wide")
st.title("AI 스마트 시간표 생성기 2025")
st.markdown("**교수명 O | 시간 겹침 0% | '운동', '경제', '영어'만 써도 AI가 알아서 추천**")

@st.cache_resource
def load_model():
    st.write("AI 모델 로딩 중... (최초 1회만 걸려요)")
    return SentenceTransformer('jhgan/ko-sroberta-multitask')

model = load_model()

FIXED_SCHEDULE = [
    {"name": "공학수학", "time": "화 9:00-10:15, 목 9:00-10:15", "prof": "강수진"},
    {"name": "고전읽기와토론", "time": "월 9:00-10:40", "prof": "황미은"},
    {"name": "일반화학2", "time": "월 15:00-16:15, 수 15:00-16:15", "prof": "조혜진"},
    {"name": "인공지능프로그래밍", "time": "화 13:30-14:45, 목 13:30-14:45", "prof": "이휘돈"},
    {"name": "일반물리학2", "time": "화 16:30-17:45, 목 16:30-17:45", "prof": "양하늬"},
]

AREAS = {1:"사상/역사", 2:"사회/문화", 3:"문학/예술", 4:"과학/기술", 5:"건강/레포츠", 6:"외국어", 7:"융복합"}

def to_min(t): 
    try: h,m = map(int,t.split(':')); return h*60+m 
    except: return 0

def parse_time(text):
    if not isinstance(text, str): return []
    text = re.sub(r'<br/?>|\n|,', ' ', text)
    slots = []
    regex = re.compile(r"([월화수목금토일])\s*(\d{1,2}:\d{2})\s*(?:[-~]\s*(\d{1,2}:\d{2})|\(\s*(\d+)\s*\))")
    yoil_map = {d:i for i,d in enumerate("월화수목금토일")}
    for m in regex.finditer(text):
        d_str, s_str, e_str, dur_str = m.groups()
        start = to_min(s_str)
        end = to_min(e_str) if e_str else start + int(dur_str or 90)
        slots.append({'day': yoil_map.get(d_str,0), 'start': start, 'end': end})
    return slots

@st.cache_data
def load_courses():
    fixed = []
    for i,d in enumerate(FIXED_SCHEDULE):
        if s := parse_time(d['time']):
            fixed.append({**d, 'id':f"maj_{i}", 'area':'전공', 'rating':5.0, 'slots':s, 'type':'major', 'time_str':d['time']})
    
    courses = []
    for i in range(1,8):
        fname = f"section{i}.csv"
        if os.path.exists(fname):
            try:
                df = pd.read_csv(fname, encoding='cp949').fillna('')
                for _, r in df.iterrows():
                    try: rating = float(r.get('교양평점', 0))
                    except: rating = 0.0
                    if s := parse_time(str(r.get('시간/강의실',''))):
                        courses.append({
                            'id': len(courses), 'name': str(r.get('교과목명(미확정구분)','')).strip(),
                            'prof': str(r.get('교수명','')).strip(), 'rating': rating,
                            'area': i, 'slots': s, 'type': 'general',
                            'time_str': str(r.get('시간/강의실','')).split(',')[0] if ',' in str(r.get('시간/강의실','')) else '',
                            'search_text': str(r.get('교과목명(미확정구분)','')) + " " + AREAS.get(i,''),
                            'match_score': 0.0
                        })
            except: pass
    return fixed, courses

fixed_courses, courses = load_courses()
if len(courses) == 0:
    st.warning("⚠️ CSV 파일이 없습니다. section1.csv ~ section7.csv 파일을 업로드해주세요!")
else:
    course_embeddings = model.encode([c['search_text'] for c in courses], convert_to_tensor=True)
    st.success(f"✅ 전공 {len(fixed_courses)}개, 교양 {len(courses)}개 로드 완료!")

def calculate_scores(kw):
    for c in courses: c['match_score'] = 0.0
    if not kw: return
    q = model.encode(kw, convert_to_tensor=True)
    sims = util.cos_sim(q, course_embeddings)[0].cpu().numpy()
    for i,s in enumerate(sims):
        courses[i]['match_score'] = float(s)*100
        if kw in courses[i]['name']: courses[i]['match_score'] += 50

def check_overlap(sched):
    slots = sorted([(s['day'], s['start'], s['end']) for c in sched for s in c['slots']])
    return any(i < len(slots)-1 and slots[i][0]==slots[i+1][0] and slots[i][2]>slots[i+1][1] for i in range(len(slots)))

def run_ai(areas, n, kw=""):
    calculate_scores(kw)
    pool = [c for c in courses if c['area'] in areas]
    if kw: pool = [c for c in pool if c['match_score'] > 30]
    pool.sort(key=lambda x: -(x['match_score']*5 + x['rating']))
    pool = pool[:60]
    
    results = []
    for _ in range(2500):
        curr = fixed_courses[:]
        picks = random.sample(pool, min(len(pool), n))
        valid = True
        for p in picks:
            if any(p['name']==c['name'] for c in curr) or check_overlap(curr+[p]):
                valid = False; break
            curr.append(p)
        if valid:
            score = sum(c['match_score']*5 + c['rating'] for c in picks)
            ids = tuple(sorted(c['id'] for c in picks))
            results.append({'score':score, 'schedule':curr, 'ids':ids})
    unique = {r['ids']:r for r in results}.values()
    return sorted(unique, key=lambda x: -x['score'])[:3]

def render(sched):
    PX, HS, HE = 1.35, 9, 19
    html = f"<style>.tt{{display:flex;font-family:Malgun Gothic;font-size:12px;border:1px solid #ddd;width:100%}}.tc{{position:relative;border-right:1px solid #eee;height:{(HE-HS)*60*PX}px;flex:1}}.card{{position:absolute;width:93%;left:3.5%;padding:5px;border-radius:6px;box-sizing:border-box;box-shadow:2px 2px 8px rgba(0,0,0,0.15);text-align:center}}</style>"
    html += "<div style='display:flex;margin-left:60px'>" + "".join([f"<div style='flex:1;text-align:center;padding:8px;background:#333;color:white;font-weight:bold'>{d}</div>" for d in "월화수목금"]) + "</div>"
    html += "<div class='tt'><div style='width:60px;background:#fafafa;position:relative'>"
    for h in range(HS, HE+1): html += f"<div style='position:absolute;top:{(h-HS)*60*PX}px;width:100%;text-align:right;padding-right:8px;font-size:11px;color:#666'>{h:02d}:00</div>"
    html += "</div>"
    for d in range(5):
        html += "<div class='tc'>"
        for c in sched:
            for s in c['slots']:
                if s['day'] == d:
                    top = (s['start'] - HS*60) * PX
                    hgt = (s['end'] - s['start']) * PX
                    if c['type']=='major': bg,bd,tag="#e3f2fd","#1976d2","전공"
                    elif c.get('match_score',0)>80: bg,bd,tag="#ffebee","#f44336","강력추천"
                    elif c.get('match_score',0)>40: bg,bd,tag="#e8f5e9","#4caf50","AI추천"
                    else: bg,bd,tag="#fff3e0","#ff9800",AREAS.get(c['area'],'교양')
                    html += f"<div class='card' style='top:{top}px;height:{hgt}px;background:{bg};border-left:5px solid {bd};color:{bd}'>"
                    html += f"<small>{tag}</small><br><b>{c['name']}</b><br>{c['prof']}</div>"
        html += "</div>"
    html += "</div>"
    st.markdown(html, unsafe_allow_html=True)

col1, col2 = st.columns([1,1])
with col1:
    st.subheader("영역 선택")
    sel = []
    for i,v in AREAS.items():
        if st.checkbox(v, key=f"a{i}"): sel.append(i+1)
with col2:
    st.subheader("설정")
    num = st.selectbox("교양 과목 수", [1,2,3], index=1)
    kw = st.text_input("AI 검색", placeholder="예: 운동, 경제, 영어, 철학, 코딩")

if st.button("시간표 생성", type="primary"):
    if not sel: st.error("영역을 선택해주세요!")
    elif len(courses) == 0: st.error("CSV 파일을 업로드해주세요!")
    else:
        with st.spinner("AI가 최적 시간표 찾는 중..."):
            res = run_ai(sel, num, kw)
        if not res:
            st.error("조건에 맞는 시간표가 없습니다")
        else:
            for i,r in enumerate(res):
                with st.expander(f"추천 {i+1}위 {'(AI 대박!)' if any(c.get('match_score',0)>40 for c in r['schedule'] if c['type']=='general') else ''}"):
                    for c in r['schedule']:
                        if c['type']=='general':
                            tag = "AI추천" if c.get('match_score',0)>40 else ""
                            st.write(f"• {c['name']} ({c['prof']}) {tag}")
                    render(r['schedule'])
